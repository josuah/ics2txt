#!/usr/bin/awk -f

# display iCal entries in plain text

function leap(yrs)
{
	return (yrs % 4 == 0) && (yrs % 100 != 0) || (yrs % 400 == 0)
}

function days_per_month(mth, yrs)
{
	if (mth == 2)
		return 28 + leap(yrs)
	else
		return 30 + (mth - (mth > 7)) % 2
}

function to_sec(yrs, mth, day, hrs, min, sec)
{
	while (--mth >= 1)
		day += days_per_month(mth, yrs)
	while (--yrs >= 1970)
		day += 365 + leap(yrs)
	return (((((day - 1) * 24) + hrs) * 60) + min) * 60 + sec
}

function to_date(fmt, sec)
{
	for (yrs = 1970; sec >= (s = 3600 * 24 * (365 + leap(yrs))); yrs++)
		sec -= s
	for (mth = 1; sec >= (s = 3600 * 24 * days_per_month(mth, yrs)); mth++)
		sec -= s
	for (day = 1; sec >= (s = 3600 * 24); day++)
		sec -= s
	for (hrs = 0; sec >= 3600; hrs++)
		sec -= 3600
	for (min = 0; sec >= 60; min++)
		sec -= 60
	return sprintf(fmt, yrs, mth, day, hrs, min, sec)
}

function date_ical(str, offset) {
	yrs = substr(str,  1, 4)
	mth = substr(str,  5, 2)
	day = substr(str,  7, 2)
	hrs = substr(str, 10, 2)
	min = substr(str, 12, 2)
	if (substr(str, 16, 1) == "Z")
		return to_sec(yrs, mth, day, hrs, min, 0)
	else
		return to_sec(yrs, mth, day, hrs, min, 0) - offset
}

function date_iso8601(date, offset)
{
	yrs = substr(date,  1, 4)
	mth = substr(date,  6, 2)
	day = substr(date,  9, 2)
	hrs = substr(date, 12, 2)
	min = substr(date, 15, 2)
	return to_sec(yrs, mth, day, hrs, min, 0) - offset
}

function swap(array, a, b)
{
	tmp = array[a]
	array[a] = array[b]
	array[b] = tmp
}

function sort(array, beg, end)
{
	if (beg >= end)					# end recursion
		return

	a = beg + 1;					# #1 is the pivot
	b = end
	while (a < b) {
		while (a < b && array[a] <= array[beg])	# beg: skip lesser
			a++
		while (a < b && array[b] > array[beg])	# end: skip greater
			b--
		swap(array, a, b);			# found 2 misplaced
	}

	if (array[beg] > array[a])			# put the pivot back
		swap(array, beg, a)

	sort(array, beg, a - 1);			# sort lower half
	sort(array, a, end);				# sort higher half
}

function parse_ical(list, offset)
{
	FS = "[:;]"

	while (getline) {
		gsub("\r", " "); gsub("\\\\[ntr]", "  "); gsub("\\\\", "")
		gsub("^ *", ""); gsub(" *$", "")
		gsub(" *<[a-zA-Z0-9/]*>* *", "")

		if (match($0, "^ ")) {
			event[type] = event[type] substr($0, 2, length($0) - 1)
		} else {
			type = $1
			i = index($0, ":")
			event[type] = substr($0, i + 1, length($0) - i)
		}

		if ($0 ~ /END:VEVENT/)
			list[++n] = sprintf("%d\t%d\t%s\t%s\t%s\t%s",
			    date_ical(event["DTSTART"], offset),
			    date_ical(event["DTEND"], offset),
			    event["SUMMARY"],
			    event["LOCATION"],
			    event["DESCRIPTION"])
	}
	sort(list, 1, n)
	return n
}

function print_fold(prefix, s, n)
{
	while (s != "") {
		line = substr(s, 1, n)
		if (length(s) > n) sub(" +[^ \t\r\n]*$", "", line)
		print prefix line
		s = substr(s, length(line) + 2)
	}
}

function print_entry(beg, end, summary, location, description, offset)
{
	b = to_date("%04d-%02d-%02d %02d:%02d", beg + offset)
	e = to_date("%04d-%02d-%02d %02d:%02d", end + offset)
	date = substr(b, 1, 10)
	hour_beg = substr(b, 12)
	hour_end = substr(e, 12)

	if (date != last_date) print "\n" date
	print "\n" hour_beg "\t" summary
	done = 0
	if (category) printf("%s\t%s\n", !done++ ? hour_end : "", category)
	if (location) printf("%s\t%s\n", !done++ ? hour_end : "", location)
	if (description) {
		printf("%s", !done++ ? hour_end : "")
		print_fold("\t", description, 70)
	}

	last_date = date
}

BEGIN {
	"date +%z" | getline offset_str
	close("date +%z")

	offset = substr(offset_str, 2, 2) * 3600
	offset += substr(offset_str, 4, 2) * 60
	if (substr(offset_str, 1, 1) == "-")
		offset *= -1

	n = parse_ical(list, offset)
	for (i = 1; i <= n; i++) {
		split(list[i], arr, "\t")
		print_entry(arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], offset)
	}
	print ""
}
